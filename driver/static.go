package driver

import (
	"github.com/HFO4/gbc-in-cloud/util"
	"image"
	"image/color"
	"image/draw"
	"log"
	"sync"
)

type StaticImage struct {
	// Origin pixel data generated by the emulator
	pixelsDirty *[160][144][3]uint8
	// clean pixels to be displayed
	pixelsClean [160][144][3]uint8
	pixelLock   sync.RWMutex

	inputStatus *byte
	inputQueue  []*inputCommand
	queueLock   sync.Mutex
}

type inputCommand struct {
	button byte
	ttl    int
	issued bool
}

func (s *StaticImage) InitStatus(b *byte) {
	s.inputStatus = b
}

func (s *StaticImage) UpdateInput() bool {
	s.queueLock.Lock()
	if len(s.inputQueue) == 0 {
		s.queueLock.Unlock()
		return false
	}
	newInput := s.inputQueue[0]
	if newInput.ttl > 0 {
		newInput.ttl--
	} else {
		s.inputQueue = s.inputQueue[1:]
	}
	s.queueLock.Unlock()

	statusCopy := *s.inputStatus
	if !newInput.issued {
		statusCopy = util.ClearBit(statusCopy, uint(newInput.button))
		newInput.issued = true
	} else {
		if newInput.ttl > 0 {
			return false
		} else {
			statusCopy = util.SetBit(statusCopy, uint(newInput.button))
		}
	}

	*s.inputStatus = statusCopy

	return true
}

func (s *StaticImage) NewInput(bytes []byte) {
	panic("implement me")
}

func (s *StaticImage) Init(pixels *[160][144][3]uint8, s2 string) {
	s.pixelsDirty = pixels
	log.Println("[Display] Initialize static image display")
}

func (s *StaticImage) Run(drawSignal chan bool, f func()) {
	for {
		// drawSignal was sent by the emulator
		<-drawSignal
		s.pixelLock.Lock()
		if s.pixelsDirty != nil {
			s.pixelsClean = *s.pixelsDirty
		}
		s.pixelLock.Unlock()
	}
}

// Render raw pixels into images
func (s *StaticImage) Render() *image.RGBA {
	scaleRatio := 4
	s.pixelLock.RLock()

	img := image.NewRGBA(image.Rect(0, 0, 160*scaleRatio, 144*scaleRatio))

	for y := 0; y < 144; y++ {
		for x := 0; x < 160; x++ {
			r, g, b := s.pixelsClean[x][y][0], s.pixelsClean[x][y][1], s.pixelsClean[x][y][2]
			var dot color.RGBA

			if r == 0xFF && g == 0xFF && b == 0xFF {
				dot.R = 0x9b
				dot.G = 0xbc
				dot.B = 0x0f
			} else if r == 0xCC && g == 0xCC && b == 0xCC {
				dot.R = 0x8b
				dot.G = 0xac
				dot.B = 0x0f
			} else if r == 0x77 && g == 0x77 && b == 0x77 {
				dot.R = 0x30
				dot.G = 0x62
				dot.B = 0x30
			} else {
				dot.R = 0x0f
				dot.G = 0x38
				dot.B = 0x0f
			}
			dot.A = 0xff

			pixelRect := image.Rect(x*scaleRatio, y*scaleRatio, (x+1)*scaleRatio, (y+1)*scaleRatio)
			draw.Draw(img, pixelRect, &image.Uniform{dot}, image.Point{}, draw.Src)

		}
	}
	s.pixelLock.RUnlock()

	return img
}

// Render raw pixels into images
func (s *StaticImage) EnqueueInput(button byte) {
	s.queueLock.Lock()
	s.inputQueue = append(s.inputQueue, &inputCommand{button, 3, false})
	s.queueLock.Unlock()
}
